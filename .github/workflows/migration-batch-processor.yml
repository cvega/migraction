name: Migration Batch Processor

on:
  repository_dispatch:
    types: [migration-batch]

jobs:
  process-batch:
    name: Batch ${{ github.event.client_payload.batch.batchNumber }} - ${{ matrix.repository }}
    runs-on: self-hosted
    strategy:
      matrix:
        repository: ${{ github.event.client_payload.batch.repositories }}
      fail-fast: false
      max-parallel: 10
    timeout-minutes: 50400

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Install common dependencies
        if: ${{ github.event.client_payload.batch.installPrereqs == 'true' || github.event.client_payload.batch.installPrereqs == '' }}
        run: |
          sudo apt-get update
          sudo apt-get install --yes git unzip curl wget apt-transport-https software-properties-common

      - name: Install GitHub Enterprise Importer
        if: ${{ github.event.client_payload.batch.installPrereqs == 'true' || github.event.client_payload.batch.installPrereqs == '' }}
        run: |
          if [ -z "$(command -v gei)" ]; then
            wget https://github.com/github/gh-gei/releases/latest/download/gei-linux-amd64
            sudo install --owner root --group root --mode 755 gei-linux-amd64 /usr/local/bin/gei
          fi
          gei --version

      - name: Install PowerShell
        if: ${{ github.event.client_payload.batch.installPrereqs == 'true' || github.event.client_payload.batch.installPrereqs == '' }}
        run: |
          if [ -z "$(command -v pwsh)" ]; then
            wget "https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb"
            sudo dpkg --install packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install --yes powershell
          fi
          pwsh --version

      - if: runner.debug
        name: GEI version number
        run: gei --version

      - if: runner.debug
        name: PowerShell version number
        run: pwsh --version

      - name: Create lock flag based on migration type
        uses: actions/github-script@v7
        id: lock-flag
        with:
          result-encoding: string
          script: |
            const migrationType = '${{ github.event.client_payload.batch.migrationType }}';
            return migrationType === 'production' ? '--lock-source-repo' : '';

      - name: Download repos visibility file
        uses: actions/download-artifact@v4
        if: github.event.client_payload.batch.targetRepositoryVisibility == 'Mirror'
        continue-on-error: true
        with:
          name: source-repos-visibility.json
          github-token: ${{ secrets.TARGET_ADMIN_TOKEN }}
          run-id: ${{ github.event.client_payload.orchestrator_run_id }}

      - name: Migrate repository
        shell: pwsh
        id: migrate
        run: |
          function Exec {
            param (
              [scriptblock]$ScriptBlock
            )
            & @ScriptBlock
            if ($lastexitcode -ne 0) {
              exit $lastexitcode
            }
          }

          function ExecAndGetMigrationID {
            param (
              [scriptblock]$ScriptBlock
            )
            $MigrationID = Exec $ScriptBlock | ForEach-Object {
              Write-Host $_
              $_
            } | Select-String -Pattern "\(ID: (.+)\)" | ForEach-Object { $_.matches.groups[1] }
            return $MigrationID
          }

          $repository = '${{ matrix.repository }}'
          $visibility = '${{ github.event.client_payload.batch.targetRepositoryVisibility }}'
          
          Write-Host "Processing repository: $repository"
          Write-Host "Batch: ${{ github.event.client_payload.batch.batchNumber }} of ${{ github.event.client_payload.batch.totalBatches }}"
          
          # Determine visibility
          if ($visibility -eq 'None') {
            $VisibilityValue = 'private'
          } elseif ($visibility -eq 'Mirror') {
            $jsonFilePath = "./source-repos-visibility.json"
            if (Test-Path $jsonFilePath) {
              $jsonContent = Get-Content -Raw -Path $jsonFilePath | ConvertFrom-Json
              if ($jsonContent.PSObject.Properties[$repository]) {
                  $visibilityValue = $jsonContent.$repository
                  if ($visibilityValue -eq 'public') {
                      $visibilityValue = 'internal'
                  }
              } else {
                  Write-Output "Repository URL not found in the JSON file...default to private"
                  $visibilityValue = 'private'
              }
            } else {
              $visibilityValue = 'private'
            }
          } else {
            $VisibilityValue = $visibility.ToLower()
          }

          # Parse repository URL
          $Parts = $repository.Split("/")
          $RepoName = $Parts[$Parts.length - 1]
          $RepoOrg = $Parts[$Parts.length -2]
          $RepoHost = $Parts[2]

          Write-Host "Repo: $repository"
          Write-Host "Visibility: $VisibilityValue"

          # Set up storage credentials
          if ('${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}' -ne '') {
            $AzureStorageIncludeArg = "--azure-storage-connection-string"
            $AzureStorageIncludeValue = "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}"
          }

          if ('${{ secrets.AWS_ACCESS_KEY_ID }}' -ne '') {
            $AwsAccessKeyIdArg = "--aws-access-key"
            $AwsAccessKeyIdValue = "${{ secrets.AWS_ACCESS_KEY_ID }}"
            $AwsSecretAccessKeyArg = "--aws-secret-key"
            $AwsSecretAccessKeyValue = "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            $AwsRegionArg = "--aws-region"
            $AwsRegionValue = "${{ vars.AWS_REGION }}"
            $AwsBucketArg = "--aws-bucket-name"
            $AwsBucketValue = "${{ vars.AWS_BUCKET_NAME }}"
          }

          # Handle GHES vs GitHub.com
          if ($RepoHost -ne 'github.com') {
            $ServerIncludeArg = "--ghes-api-url" 
            $ServerIncludeValue = "https://$($RepoHost)/api/v3"
          }

          try {
            $MigrationID = ExecAndGetMigrationID {
              gei migrate-repo `
              --source-repo $RepoName `
              --target-repo $RepoName `
              --github-source-org $RepoOrg `
              --github-target-org '${{ github.event.client_payload.batch.targetOrganization }}' `
              --target-repo-visibility $VisibilityValue `
              $AzureStorageIncludeArg $AzureStorageIncludeValue `
              $ServerIncludeArg $ServerIncludeValue `
              $AwsAccessKeyIdArg $AwsAccessKeyIdValue `
              $AwsSecretAccessKeyArg $AwsSecretAccessKeyValue `
              $AwsRegionArg $AwsRegionValue `
              $AwsBucketArg $AwsBucketValue `
              ${{ steps.lock-flag.outputs.result }} `
              --skip-releases `
              --queue-only
            }
            
            if ($MigrationID) {
              Write-Host "Queued migration of repository $RepoName with ID $MigrationID"
              Write-Host "Waiting for migration to complete..."
              
              gei wait-for-migration --migration-id $MigrationID
              Write-Host "Migration completed successfully"
            } else {
              Write-Host "Failed to queue migration for repository $RepoName"
              exit 1
            }
          } catch {
            Write-Host "Error processing repository $repository : $_"
            exit 1
          }
        env:
          GH_PAT: ${{ secrets.TARGET_ADMIN_TOKEN }}
          GH_SOURCE_PAT: ${{ secrets.SOURCE_ADMIN_TOKEN }}

      # run additional migration workflows
      - name: Check if repo has LFS data
        id: lfs-check
        run: |
          OUTPUT=$(node .github/scripts/check-csv-repo.cjs lfs.csv "${{ matrix.repository }}")
          echo "$OUTPUT" >> $GITHUB_OUTPUT

      - name: Dispatch LFS workflow
        if: steps.lfs-check.outputs.found == 'true'
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: migration-lfs.yml
          token: ${{ secrets.TARGET_ADMIN_TOKEN }}
          inputs: |
            {
              "repository": "${{ matrix.repository }}"
            }

      - name: Check if repo has packages
        id: packages-check
        run: |
          OUTPUT=$(node .github/scripts/check-csv-repo.cjs packages.csv "${{ matrix.repository }}")
          echo "$OUTPUT" >> $GITHUB_OUTPUT

      - name: Dispatch packages workflow
        if: steps.packages-check.outputs.found == 'true'
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: migration-packages.yml
          token: ${{ secrets.TARGET_ADMIN_TOKEN }}
          inputs: |
            {
              "repository": "${{ matrix.repository }}"
            }

      - name: Check if repo has releases
        id: releases-check
        run: |
          REPO_PATH=$(echo "${{ matrix.repository }}" | sed -E 's#https?://[^/]+/##')
          DIR="/opt/migration/releases/$REPO_PATH"
          if [ -d "$DIR" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "releases_path=$DIR" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "releases_path=$DIR" >> $GITHUB_OUTPUT
          fi

      - name: Dispatch releases workflow
        if: steps.releases-check.outputs.found == 'true'
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: migration-releases.yml
          token: ${{ secrets.TARGET_ADMIN_TOKEN }}
          inputs: |
            {
              "releases_path": "${{ steps.releases-check.outputs.releases_path }}"
            }

      - name: Reclaim mannequins
        continue-on-error: true
        run: |
          if [ -f "user-mappings-gei.csv" ]; then
            gei reclaim-mannequin \
              --csv user-mappings-gei.csv \
              --github-target-org ${{ github.event.client_payload.batch.targetOrganization }} \
              --github-target-pat ${{ secrets.TARGET_ADMIN_TOKEN }}
          else
            echo "No user-mappings-gei.csv file found, skipping mannequin reclaim"
          fi

      - name: Write repo migration status
        if: always()
        id: write-status
        run: |
          reponame=$(basename ${{ matrix.repository }})
          echo "repo-name=$reponame" >> "$GITHUB_OUTPUT" 
          echo "${{ matrix.repository }}, ${{ job.status }}" > ${reponame}.txt

      - name: Upload repo migration status
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: migration-status-batch-${{ github.event.client_payload.batch.batchNumber }}-${{ steps.write-status.outputs.repo-name }}
          path: ${{ steps.write-status.outputs.repo-name }}.txt

  batch-summary:
    name: Batch ${{ github.event.client_payload.batch.batchNumber }} Summary
    runs-on: ubuntu-latest
    needs: process-batch
    if: always()
    steps:
      - name: Download batch migration statuses
        uses: actions/download-artifact@v4
        with:
          pattern: migration-status-batch-${{ github.event.client_payload.batch.batchNumber }}-*
          path: batch-${{ github.event.client_payload.batch.batchNumber }}-status
          merge-multiple: true

      - name: Create batch status summary
        uses: actions/github-script@v7
        env:
          BATCH_INFO: ${{ toJson(github.event.client_payload.batch) }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const batchInfo = JSON.parse(process.env.BATCH_INFO);

            let successfulRepos = [];
            let failedRepos = [];
            const dir = `batch-${batchInfo.batchNumber}-status`;

            if (fs.existsSync(`./${dir}`)) {
              fs.readdirSync(`./${dir}`).forEach(file => {
                if (path.extname(file) === '.txt') {
                  let [repo, status] = fs.readFileSync(`${dir}/${file}`, 'utf-8').split(',');
                  if (status.trim() === 'success') {
                    successfulRepos.push(repo);
                  } else {
                    failedRepos.push(repo);
                  }
                }
              });
            }

            const batchStatus = {
              batchNumber: batchInfo.batchNumber,
              totalBatches: batchInfo.totalBatches,
              successful: successfulRepos,
              failed: failedRepos,
              totalProcessed: successfulRepos.length + failedRepos.length,
              migrationId: batchInfo.migrationId,
              migrationType: batchInfo.migrationType
            };

            fs.writeFileSync(`batch-${batchInfo.batchNumber}-status.json`, JSON.stringify(batchStatus, null, 2));
            
            // Post summary comment to the original issue
            const successIcon = failedRepos.length === 0 ? ':white_check_mark:' : ':warning:';
            let body = `${successIcon} **Batch ${batchInfo.batchNumber} of ${batchInfo.totalBatches} Complete**\n\n`;
            body += `**Successful:** ${successfulRepos.length}\n`;
            body += `**Failed:** ${failedRepos.length}\n`;
            body += `**Total:** ${successfulRepos.length + failedRepos.length}\n\n`;
            
            if (failedRepos.length > 0) {
              body += `**Failed Repositories:**\n\`\`\`\n${failedRepos.slice(0, 10).join('\n')}`;
              if (failedRepos.length > 10) {
                body += `\n... and ${failedRepos.length - 10} more`;
              }
              body += `\n\`\`\`\n\n`;
              body += `ðŸ’¡ **Tip:** You can re-run this batch by manually triggering the migration-batch-processor workflow.`;
            }
            
            body += `\n\n[View batch details â†’](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

            await github.rest.issues.createComment({
              issue_number: batchInfo.issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Upload batch status
        uses: actions/upload-artifact@v4
        with:
          name: batch-${{ github.event.client_payload.batch.batchNumber }}-status
          path: batch-${{ github.event.client_payload.batch.batchNumber }}-status.json
